#include "project1.h"
#include <vector>
#include <iostream>
#include <bits/stdc++.h>
#include <cmath>
#include <stdio.h>
#include <ctime>
#include <math.h>
#include <random>
#include <utility>
#include <algorithm>

using namespace std;

struct timing 
{
    int n;
    double seconds;
};



/**
 * prints the contents of vector nums
 */

void print_the_nums( vector<int>& nums)
{
		for ( vector<int>::const_iterator i = nums.begin(); i !=nums.end(); ++i){
   			  cout << *i << ' ' << '\n';
	}

}

/**
 *First implementation of three phase annealing sorting with temperature and repetition sequence
 */

void annealing_sort1( vector<int>& nums)
{
	 vector<int> temp, reps;
	//phase 1 to get T1 and R1
	int div=1;
	int q=1;
	int g =64; //should be the analysis of algorithm
	int c=2;

	for (int i=0; i<8; i++){
		temp.push_back((2*nums.size())/div);
		div=(!(i%2))?div*2:div;			
	}

	for(int i =0; i<10; i++){
		reps.push_back(c);
	}
	temp.push_back(q*pow(log2(nums.size()),6));
	temp.push_back(q*pow(log2(nums.size()),6));
	
	
	//phase 2 to get T2 and R2
	div=1;
	for (int i=0 ; i<9; i++){
		temp.push_back((q/div)*(pow(log2(nums.size()),6)));
		div=div*2;

	}

	
	temp.push_back(g*pow(log2(nums.size()),6));

	for(int i =0; i<10; i++){
		reps.push_back((log2(nums.size()))/(log2(log2(nums.size()))));
	}


	//phase 3 to get T3 and R3
	for(int i=0; i <(g*log2(nums.size())); i++){
		temp.push_back(1);
		reps.push_back(1);
	}

	temp.push_back(0);
	reps.push_back(0);	
	annealing_sort(nums,temp,reps);
}


/**
 * Second implementation of three annealing sort using same temperature and repitition sequence but with different q, c, and g
 */
void annealing_sort2( vector<int>& nums)
{
	 vector<int> temp, reps;
	//phase 1 to get T1 and R1
	int div=1;
	int q=2;
	int g =64; //should be the analysis of algorithm
	int c=4;

	for (int i=0; i<8; i++){
		temp.push_back((2*nums.size())/div);
		div=(!(i%2))?div*2:div;			
	}

	for(int i =0; i<10; i++){
		reps.push_back(c);
	}
	temp.push_back(q*pow(log2(nums.size()),6));
	temp.push_back(q*pow(log2(nums.size()),6));

		
	//phase 2 to get T2 and R2
	div=1;
	for (int i=0 ; i<9; i++){
		temp.push_back((q/div)*(pow(log2(nums.size()),6)));
		div=div*2;

	}

	temp.push_back(g*pow(log2(nums.size()),6));

	for(int i =0; i<10; i++){
		reps.push_back((log2(nums.size()))/(log2(log2(nums.size()))));
	}
	


	//phase 3 to get T3 and R3
	for(int i=0; i <(g*log2(nums.size())); i++){
		temp.push_back(1);
		reps.push_back(1);
	}
	temp.push_back(0);
	reps.push_back(0);
	
	annealing_sort(nums,temp,reps);
}

/**
 * First implementation of shell sort  
 */
void shell_sort1( vector<int>& nums)
{
	 vector<int> gaps;
	gaps.push_back(1);
	gaps.push_back(4);
	gaps.push_back(10);	
	gaps.push_back(23);
	gaps.push_back(57);
	gaps.push_back(132);
	gaps.push_back(301);
	gaps.push_back(701);

	shell_sort(nums, gaps);

}


/**
 * Second implementation of shell sort using fibonacci sequence as gap sequence
 */

void generating_fibonacci( vector<int>& gaps2)
{	
	gaps2.push_back(0);
	gaps2.push_back(1);
	for(int i =2; i <=10;i++)//may be change the size of the sequence
	{
		gaps2.push_back(gaps2[i-1]+gaps2[i-2]);

	}	
}

/**
 * Second implementaiion of spin_the_bottle sorting just using fibonnacci sequence
 */
void shell_sort2( vector<int>& nums)
{
	
	 vector<int> gaps2;
	generating_fibonacci(gaps2);
	shell_sort(nums,gaps2);	

}

/**
 *Almost sorted permutation generated by using sorted vector and indepently choosing 2logn pairs (i,j)
*where i and j are uniform-chosen random integers in the range from 0 to n-1 and swap the numbers at
*position i and j 
*/
void almost_sorted( int n,vector<int>& nums)
{
	nums.clear();
	cout<<"hello";	

	for (int i=0; i < n;i++){
		nums.push_back(i+1);
	}
	
	for (int i=0; i < (2*log10(nums.size())); i++){
		random_device rd;
		mt19937 generator(rd());
		 uniform_int_distribution<int> distr(0,i+1);
		int j=distr(generator);
		 swap(nums[i],nums[j]);
		
	}
}



/**
 * Generating uniformly_sorted permutations using Fisher Yates algorithm
 */
void uniformly_sorted(int n, vector<int>& nums)
{
	nums.clear();

	random_device rd;
	mt19937 generator(rd());
	
	for(int i =0; i <n; i++){
		nums.push_back(i+1);
	}

	for (int k=(nums.size()-1);k >=0 ;k--)
	{
		 uniform_int_distribution<int> distr(0,k+1);
		int j=distr(generator);
		 swap(nums[k],nums[j]);
		
	}
}

/**
 * Measuring the run time of all the sorting algorithms
 */
timing time_sort(int n, int reps,  vector<int>& nums,int sort_opt,int per_opt)
{
    double total_time = 0.0;
    for(int i = 0; i < reps; i++)
    {
		(per_opt==0)?almost_sorted(n,nums):uniformly_sorted(n,nums);
        clock_t c_start = clock();
        switch(sort_opt){
			case 1:bubble_sort(nums);
					break;
			case 2:insertion_sort(nums);
					break;
			case 3:spin_the_bottle_sort(nums);
					break;
			case 4:shell_sort1(nums);
					break;
			case 5:shell_sort2(nums);
					break;
			case 6:annealing_sort1(nums);
					break;
			case 7:annealing_sort2(nums);
					break;
		}
		clock_t c_end = clock();
        total_time += (float)(c_end - c_start) / CLOCKS_PER_SEC;
    }
    timing t;
    t.n = n;
    t.seconds = (float)total_time/reps;
    return t;
}

// create/truncate a file with chosen filename. insert csv header "funcname,n,seconds"
void create_empty_timings_file( string filename)
{
    ofstream f;
    f.open(filename, ios::trunc);
    f << "funcname,n,seconds\n";
    f.close();
}

// append timings data in csv format to a file with no header. (header should be created first)
void add_timings_to_file(string funcname, timing t,  string filename)
{
    ofstream f;
    f.open(filename, ios::app);
    f << funcname << "," << t.n << "," << t.seconds << "\n";
    f.close();
}

//calling the time function and adding the measured file csv file
void calling_timing( vector<int>& nums,  string sortname,int sort_opt, int per_opt,string filename)
{
	create_empty_timings_file(filename);
	timing t;
	for(int n=10; n<=1000; n *=10)
	{
		t=time_sort(n,3,nums,sort_opt,per_opt);
		add_timings_to_file(sortname,t,filename);

	}
	
}

	

int main()
{
	 vector<int> nums;
	
	//BUBBLE SORT
//	calling_timing(nums,"bubblesort",1,0,"bubblesort_almost.csv");
//	calling_timing(nums,"bubblesort",1,1,"bubblesort_uniform.csv");
	
	//INSERTION SORT
//	calling_timing(nums,"insertion",2,0,"insertion_almost.csv");
//	calling_timing(nums,"insertion",2,1,"insertion_uniform.csv");

	//SHELL SORTING
//	calling_timing(nums,"shell1",4,0,"shell1_almost.csv");
//	calling_timing(nums,"shell1",4,1,"shell1_uniform.csv");

//	calling_timing(nums,"shell2",5,0,"shell2_almost.csv");
//	calling_timing(nums,"shell2",5,1,"shell2_uniform.csv");
	

	//SPIN-THE-BOTTLE
	calling_timing(nums,"spin_the_bottle",3,0,"spin_the_bottle_almost.csv");
	calling_timing(nums,"spin_the_bottle",3,1,"spin_the_bottle_uniform.csv");

	//ANNEALING SORTING
//	calling_timing(nums,"annealing1",6,0,"annealing1_almost.csv");
//	calling_timing(nums,"annealng1",6,1,"annealing1_uniform.csv");

//	calling_timing(nums,"annealing2",6,0,"annealing2_almost.csv");
//	calling_timing(nums,"anneaing2",6,1,"annealing2_uniform.csv");

}
